# Java 疑惑点 <!-- {docsify-ignore} -->
记录一些对 java 的语言设计的思考，统一进行梳理了解。
## 为什么在超类中声明变量
变量的声明类型为超类型（抽象类或接口类），为行为接口类型声明一个引用变量，所以子类都继承它们。      
在运行时才指定具体实现的对象。（如：duck 类声明接口类的实例变量；每个实例的鸭子对象都会引用实现 xx 接口的对象，这样每个鸭子对象都会动态地设置这些变量以在运行时引用正确的行为类型；

使用在：定义返回变量类型的方法；//使用该变量用于方法返回类型

## 类和对象的区分
类：指 class 定义一个类
对象：指用构造方法实例化类

## this  关键字的使用
1. this 用于引用当前类的实例变量，用来区分局部参数
参数(形式参数)和实例变量(rollno 和 name)相同时，如果实例变量和参数之间存在歧义，则 this 关键字可用于明确地指定类变量以解决歧义问题。
```
class Student {
    int rollno;//实例变量
    String name;
    float fee;

    Student(int rollno, String name, float fee) {
        this.rollno = rollno;//this.rollno 指实例变量，this 引用实例变量
        this.name = name;
        this.fee = fee;
    }
```
2. 调用当前类方法
```
void a(){}
	void b(){
		this.a();
	}
```
3. 调用当前类的构造方法     
用于重载构造方法，先调用当前类的构造方法。调用this()必须是构造函数中的第一个语句。

4. 作为参数传递给方法     
在多个方法中重用一个对象，如事件处理。
```
void m(S2 obj) {
     System.out.println("method is invoked");
}
void p() {
    m(this);
}
```
5. 在构造函数调用中作为参数传递，如在多个类中使用一个对象
```
A4() {
        B b = new B(this);
        b.display();
    }
```
6. 用来返回当前类的实例     
方法的返回类型必须是类类型(非原始)
```
A getA() {
        return this;
    }
```

## 类里覆写 toString() 方法
将对象按字符串的方式输出出来，用白话说就是：使用文字描述这个对象里各个变量是什么值 ，这个变量是什么类型的变量等 ，并且任何类都从 Object 继承了这个方法，若不重写 toString() 方法的话输出的就是一个内存地址，也就是哈希码值。并不是输出这个类的各个变量的值

## setter 方法
通过 setter 方法设定类行为，可以随时调用 getter/setter 这两个方法改变类的行为。用在运行是改变类的行为。用于封装类

## delegate 委派或委托
委托：一个对象请求另一个对象的功能，捕获一个操作并将其发送到另一个对象。

委托依赖于动态绑定，因为它要求特定的方法可以在运行时调用不同的代码段。
```
public class A {
}

public class B {
    private A a;
    public B(A a) {
        this.a = a; 
    }
}
```
委托的几种类型归纳：临时性依赖（use），永久性关联（has-a），组合        
- 临时性依赖：作为迭代器中的元素和方法中的参数来使用      
如 List<接口类> 接口类列表，一对多，观察者依赖主题。主题唯一依赖的东西是一个实现观察者接口的对象列表
- 永久性关联：允许一个对象实例让另一个对象实例代表它自己做其他事。它指定了一种对象与另一种对象相连接，并且不代表行为，即不在该类的方法中使用另一个类的方法，只是简单的将不同的对象连接起来。互相都有彼此的实例，直接将这几个不同的类相连接。
- 组合：一个类有另一个属性或实例变量——实现了一个对象包含另一个对象。        
在该类中实例化一个其他类，然后调用方法调用其他类的方法，对这个实例想怎么用怎么用。这里的实例是 private，外界访问不到，若更改其值只能在该方法中；而且每次创建该类的对象时，就已经创建好这个类中的实例；也就是说一旦创建好该类的对象，其中的属性指向便已经创建好。
```
class Heart {}
class Person { 
    private Heart heart = new Heart();
    public void operation () { 
        heart.operation(); 
    }
}
```
在组合中，当拥有的对象被销毁时，所包含的对象也是如此。如人被销毁则心脏也不存在。
- 聚集：对象存在于另一个之外，是在外部创建的，所以它作为一个参数传递给构造函数。
```
public class Milk extends CondimentDecorator {
    //Milk 类引用 Beverage
    //操作步骤：声明实例变量，通过构造器将饮料记录在实例变量中
    Beverage beverage;

    public Milk(Beverage beverage) {
        this.beverage = beverage;
    }
}
```
内部的属性是可以在外部指定的，而不是完全依赖该类。


## 面向对象编程
多态：运行期才能动态决定调用的子类方法，可能是调用子类的覆写方法。添加更多类型的子类实现功能扩展，却不需要修改基于父类的代码。      

### 抽象类
父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：
```
class Person {
    public abstract void run();
}
```
一个方法声明为 abstract，表示它是一个抽象方法，本身没有实现任何方法语句。因为这个抽象方法本身是无法执行的，对应类也定义为抽象类，且无法实例化。     

无法实例化的抽象类有什么用？        
因为抽象类本身被设计成只能用于被继承，因此，抽象类可以强迫子类实现其定义的抽象方法。

- 上层代码只定义规范
- 不需要子类就可以实现业务逻辑（正常编译）；
- 具体的业务逻辑由不同的子类实现，调用者并不关心。

抽象类，定义抽象方法，构造方法，字段；
其继承子类，实现抽象方法，继承父类构造方法和字段（不要再声明）；        
当我们定义了抽象类 Person，以及具体的 Student、Teacher 子类的时候，我们可以通过抽象类 Person 类型去引用具体的子类的实例，并对其进行方法调用，并不关心 Person 类型变量的具体子类型：
```
Person s = new Student();
Person t = new Teacher();
// 不关心Person变量的具体子类型:
s.run();
t.run();
```
通过 abstract 定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；如果不实现抽象方法，则该子类仍是一个抽象类；

### 接口
在抽象类中，抽象方法本质上是定义接口规范：即规定高层类的接口，从而保证所有子类都有相同的接口实现。如果一个抽象类没有字段，所有方法全部都是抽象方法，可以把抽象类改写为接口：interface。

所谓 interface，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是 public abstract 的，所以这两个修饰符不需要写出来（写不写效果都一样）。

接口：接口层次代表抽象程度

抽象类：公共逻辑，具体逻辑放到各个子类

接口—》抽象类（实现接口类）—》具体子类（继承抽象类）

List—》AbstractList—》ArrayList
```
List list = new ArrayList(); // 用List接口引用具体子类的实例
Collection coll = list; // 向上转型为Collection接口
Iterable it = coll; // 向上转型为Iterable接口
```
接口类：只定义方法，没有字段和构造方法；

实现类：实现方法，定义字段和构造方法；
## 静态字段 static
- 静态字段 static field     
实例字段在每个实例中都有自己的一个独立“空间”，但是静态字段只有一个共享“空间”，所有实例都会共享该字段。       
访问静态字段，用类名来访问静态字段

- 静态方法      
静态方法属于 class 而不属于实例，因此，静态方法内部，无法访问this变量，也无法访问实例字段，它只能访问静态字段。     
调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。      
静态方法经常用于工具类。例如：      
`Arrays.sort()`     
`Math.random()`

- 接口的静态字段        
接口不能实例字段，但是，interface是可以有静态字段的，并且静态字段必须为 final 类型

- 静态代码块，类中的 static{ } 代码块       
主要用于初始化类，为类的静态变量赋初始值。Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。

- 静态类，静态内部类（Static Nested Class）
一个完全独立的类，可以访问外部类 private 的静态字段和静态方法

## 作用域
public、protected、private 修饰符可以用来限定访问作用域。
- public

类为 public 则可以被其他包的类访问      
字段和方法 为 public 可以被其他类访问，方法被调用，前提是首先有访问class的权限；        
public 方法定义了类对外提供的功能，放在 class 内部的签名

- private

字段和方法为 private 无法被其他类访问，放在 class  内部的后面。

- protected

protected 作用于继承关系。定义为protected的字段和方法可以被子类访问，以及子类的子类。

- package

包作用域是指一个类允许访问同一个 package 的类、字段和方法，其没有修饰符。

## 局部变量

在方法内部定义的变量称为局部变量，局部变量作用域从变量声明处开始到对应的块结束。方法参数也是局部变量。

使用局部变量时，应该尽可能把局部变量的作用域缩小，尽可能延后声明局部变量。

## final
- 用 final 修饰 class 可以阻止被继承
```
// 无法被继承:
public final class Hello {}
```
- 用 final 修饰 method 可以阻止被子类覆写

- 用 final 修饰 field 可以阻止被重新赋值

- 用 final 修饰局部变量可以阻止被重新赋值

## 内聚耦合

### 内聚
主要关注于事物是怎么联系在一起的。内聚衡量了一个类或者方法的职责关联得有多强。换句话说，有多少功能是属于一起的。

内聚性高的类会将类中有相关的方法组合在一起。对方法进行分组：功能性、信息性、时间性。

- 功能性：按功能对方法进行分组，方法是一起工作的
- 信息性：处理相同的数据或者领域对象，如 DAO 封装对数据源的访问，用来维护领域对象的表的数据库进行交互
- 时间性：类是执行一些只在时间上相关的操作的类

内聚高的方法：一个方法中不含不相关的关注点，方法中不包含对类的许多不同字段或参数进行修改。

### 耦合
关于你如何依赖其他类的。需要依赖多少某些特定类的知识（具体实现）。

对于某个类依赖其他类，所依赖的类可使用接口类来将其解藕成不同的组件。不再耦合一个特定的实现。

## 异常什么时候抛出
不受检查、受检查异常        
三种方式抛出异常
- 声明方法中 throws 抛出异常让更上一层的调用者处理
- 方法体中使用 try catch 尝试去捕获异常，
- 方法中使用 throw 将产生的异常抛出，抛出的可以是异常的引用也可以是异常对象，throw 强调动作。
如：方法体内，方法返回值为空 void。如进行抛出异常，使用 if else 方式
```
if (n > 0) {
     System.out.println(n + " deleted.");
    } else {
            throw new RuntimeException("deleted failed.");
}
```